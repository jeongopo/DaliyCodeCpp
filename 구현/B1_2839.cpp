#include <iostream>
using namespace std;

/*
	문제풀이 과정 :
	- 18의 경우, 18을 5로 나누고 나머지 3을 3으로 나누어 각각의 몫을 더한 4가 정답이 되었다.
	- 이 방법처럼 5로 나누고 그 나머지를 이용하거나(1), 3으로 나누고 그 나머지를 이용한 후(2) 몫의 최댓값을 구해보려고 했다.
	- 그러나 반례 24의 경우, (1)은 -1, (2)는 8이 되지만 실제로 답은 6이다.(5묶음 3개, 3묶음 3개)
	- 따라서, 모든 경우의 수를 반복문을 이용해 구해주기로 했다.
	- 고등수학 경우의 수에서, x+y=n인경우, x가 0일 때부터, n일때까지를 모두 구하는 것처럼, 5묶음이 0개일 때부터, 5묶음의 최대(n/5)까지 반복문을 돌렸다.
	- 그 때의 나머지값에서 3을 나누었을 때 나누어 떨어지면 그 값을 채택하는 방식으로 문제를 풀었다.
*/

int main() {
	int n;
	cin >> n;

	int ret = -1;
	int tem;
	for (int i = 0; i < (n / 5) + 1; i++) {
		tem = n - 5 * i;
		if (tem % 3 == 0) {
			tem = tem / 3 + i;
			if (ret == -1 || tem < ret)	ret = tem;
		}
	}

	cout << ret << "\n";
}